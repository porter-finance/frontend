# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Account {
    "List of Bid objects"
    bids(first: Int = 100, orderBy: Bid_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Bid_filter): [Bid!]
    "Account address"
    id: ID!
    "List of TokenBalance objects"
    tokenBalances(first: Int = 100, orderBy: TokenBalance_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenBalance_filter): [TokenBalance!]
    "User ID assigned by Gnosis Auction contract"
    userid: String
}

type Auction {
    "Object reference to an ERC20 Token"
    bidding: Token!
    "Object reference to a Bond"
    bond: Bond
    "Price that each bond was sold at denominated in the bidding token"
    clearing: Bytes!
    "Auction end timestamp"
    end: BigInt!
    "Quantity of bonds sold"
    filled: BigInt!
    "Gnosis Auction ID"
    id: ID!
    isSellingPorterBond: Boolean!
    "If the auction is currently ongoing, or if it has ended"
    live: Boolean!
    "Minimum amount of bidding tokens to buy full size"
    minimum: BigInt!
    "Total number of bonds to be auctioned"
    size: BigInt!
    "Auction start timestamp"
    start: BigInt!
}

type Bid {
    "Object reference to Account"
    account: Account!
    "Gnosis Auction ID"
    auction: Int!
    "Encoding of user ID, bid buy amount and bid sell amount"
    bytes: String!
    "Transaction hash of bid cancellation"
    canceltx: Bytes
    "Transaction hash of bid claim"
    claimtx: Bytes
    "Transaction hash of bid creation"
    createtx: Bytes!
    "Concatenation of Gnosis Auction ID, user ID, bid buy amount and bid sell amount"
    id: ID!
    "Total amount of collateral paid by bidder"
    payable: BigInt!
    "Quantity of bonds"
    size: BigInt!
    "Bid timestamp"
    timestamp: BigInt!
}

type Bond {
    amountUnpaid: BigInt!
    collateralRatio: BigInt!
    collateralToken: Token!
    collateralTokenAmount: BigInt!
    convertibleRatio: BigInt!
    convertibleTokenAmount: BigInt!
    decimals: Int!
    id: ID!
    maturityDate: BigInt!
    maxSupply: BigInt!
    name: String!
    owner: Bytes!
    paymentToken: Token!
    state: BondState
    symbol: String!
    tokenBalances(first: Int = 100, orderBy: TokenBalance_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenBalance_filter): [TokenBalance!]!
    type: BondType
}

type BondFactory {
    bondCount: BigInt!
    bonds(first: Int = 100, orderBy: Bond_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Bond_filter): [Bond!]
    id: ID!
    isIssuerAllowListEnabled: Boolean!
    isTokenAllowListEnabled: Boolean!
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    account(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Account_filter
    ): [Account!]!
    auction(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Auction
    auctions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Auction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Auction_filter
    ): [Auction!]!
    bid(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Bid
    bids(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Bid_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Bid_filter
    ): [Bid!]!
    bond(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Bond
    bondFactories(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: BondFactory_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: BondFactory_filter
    ): [BondFactory!]!
    bondFactory(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BondFactory
    bonds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Bond_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Bond_filter
    ): [Bond!]!
    token(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokenBalance(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenBalance
    tokenBalances(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenBalance_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenBalance_filter
    ): [TokenBalance!]!
    tokens(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Token_filter
    ): [Token!]!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    account(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Account_filter
    ): [Account!]!
    auction(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Auction
    auctions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Auction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Auction_filter
    ): [Auction!]!
    bid(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Bid
    bids(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Bid_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Bid_filter
    ): [Bid!]!
    bond(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Bond
    bondFactories(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: BondFactory_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: BondFactory_filter
    ): [BondFactory!]!
    bondFactory(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BondFactory
    bonds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Bond_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Bond_filter
    ): [Bond!]!
    token(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokenBalance(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenBalance
    tokenBalances(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenBalance_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenBalance_filter
    ): [TokenBalance!]!
    tokens(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Token_filter
    ): [Token!]!
}

type Token {
    "Token decimals"
    decimals: Int!
    "Token address"
    id: ID!
    "Token name"
    name: String!
    "Token symbol"
    symbol: String!
}

type TokenBalance {
    account: Account!
    amount: BigInt!
    bond: Bond!
    id: ID!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum Account_orderBy {
    bids
    id
    tokenBalances
    userid
}

enum Auction_orderBy {
    bidding
    bond
    clearing
    end
    filled
    id
    isSellingPorterBond
    live
    minimum
    size
    start
}

enum Bid_orderBy {
    account
    auction
    bytes
    canceltx
    claimtx
    createtx
    id
    payable
    size
    timestamp
}

enum BondFactory_orderBy {
    bondCount
    bonds
    id
    isIssuerAllowListEnabled
    isTokenAllowListEnabled
}

enum BondState {
    active
    defaulted
    paid
    paidEarly
}

enum BondType {
    convert
    simple
}

enum Bond_orderBy {
    amountUnpaid
    collateralRatio
    collateralToken
    collateralTokenAmount
    convertibleRatio
    convertibleTokenAmount
    decimals
    id
    maturityDate
    maxSupply
    name
    owner
    paymentToken
    state
    symbol
    tokenBalances
    type
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum TokenBalance_orderBy {
    account
    amount
    bond
    id
}

enum Token_orderBy {
    decimals
    id
    name
    symbol
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

input Account_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    userid: String
    userid_contains: String
    userid_contains_nocase: String
    userid_ends_with: String
    userid_ends_with_nocase: String
    userid_gt: String
    userid_gte: String
    userid_in: [String!]
    userid_lt: String
    userid_lte: String
    userid_not: String
    userid_not_contains: String
    userid_not_contains_nocase: String
    userid_not_ends_with: String
    userid_not_ends_with_nocase: String
    userid_not_in: [String!]
    userid_not_starts_with: String
    userid_not_starts_with_nocase: String
    userid_starts_with: String
    userid_starts_with_nocase: String
}

input Auction_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    bidding: String
    bidding_contains: String
    bidding_contains_nocase: String
    bidding_ends_with: String
    bidding_ends_with_nocase: String
    bidding_gt: String
    bidding_gte: String
    bidding_in: [String!]
    bidding_lt: String
    bidding_lte: String
    bidding_not: String
    bidding_not_contains: String
    bidding_not_contains_nocase: String
    bidding_not_ends_with: String
    bidding_not_ends_with_nocase: String
    bidding_not_in: [String!]
    bidding_not_starts_with: String
    bidding_not_starts_with_nocase: String
    bidding_starts_with: String
    bidding_starts_with_nocase: String
    bond: String
    bond_contains: String
    bond_contains_nocase: String
    bond_ends_with: String
    bond_ends_with_nocase: String
    bond_gt: String
    bond_gte: String
    bond_in: [String!]
    bond_lt: String
    bond_lte: String
    bond_not: String
    bond_not_contains: String
    bond_not_contains_nocase: String
    bond_not_ends_with: String
    bond_not_ends_with_nocase: String
    bond_not_in: [String!]
    bond_not_starts_with: String
    bond_not_starts_with_nocase: String
    bond_starts_with: String
    bond_starts_with_nocase: String
    clearing: Bytes
    clearing_contains: Bytes
    clearing_in: [Bytes!]
    clearing_not: Bytes
    clearing_not_contains: Bytes
    clearing_not_in: [Bytes!]
    end: BigInt
    end_gt: BigInt
    end_gte: BigInt
    end_in: [BigInt!]
    end_lt: BigInt
    end_lte: BigInt
    end_not: BigInt
    end_not_in: [BigInt!]
    filled: BigInt
    filled_gt: BigInt
    filled_gte: BigInt
    filled_in: [BigInt!]
    filled_lt: BigInt
    filled_lte: BigInt
    filled_not: BigInt
    filled_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isSellingPorterBond: Boolean
    isSellingPorterBond_in: [Boolean!]
    isSellingPorterBond_not: Boolean
    isSellingPorterBond_not_in: [Boolean!]
    live: Boolean
    live_in: [Boolean!]
    live_not: Boolean
    live_not_in: [Boolean!]
    minimum: BigInt
    minimum_gt: BigInt
    minimum_gte: BigInt
    minimum_in: [BigInt!]
    minimum_lt: BigInt
    minimum_lte: BigInt
    minimum_not: BigInt
    minimum_not_in: [BigInt!]
    size: BigInt
    size_gt: BigInt
    size_gte: BigInt
    size_in: [BigInt!]
    size_lt: BigInt
    size_lte: BigInt
    size_not: BigInt
    size_not_in: [BigInt!]
    start: BigInt
    start_gt: BigInt
    start_gte: BigInt
    start_in: [BigInt!]
    start_lt: BigInt
    start_lte: BigInt
    start_not: BigInt
    start_not_in: [BigInt!]
}

input Bid_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    account: String
    account_contains: String
    account_contains_nocase: String
    account_ends_with: String
    account_ends_with_nocase: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_contains_nocase: String
    account_not_ends_with: String
    account_not_ends_with_nocase: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_not_starts_with_nocase: String
    account_starts_with: String
    account_starts_with_nocase: String
    auction: Int
    auction_gt: Int
    auction_gte: Int
    auction_in: [Int!]
    auction_lt: Int
    auction_lte: Int
    auction_not: Int
    auction_not_in: [Int!]
    bytes: String
    bytes_contains: String
    bytes_contains_nocase: String
    bytes_ends_with: String
    bytes_ends_with_nocase: String
    bytes_gt: String
    bytes_gte: String
    bytes_in: [String!]
    bytes_lt: String
    bytes_lte: String
    bytes_not: String
    bytes_not_contains: String
    bytes_not_contains_nocase: String
    bytes_not_ends_with: String
    bytes_not_ends_with_nocase: String
    bytes_not_in: [String!]
    bytes_not_starts_with: String
    bytes_not_starts_with_nocase: String
    bytes_starts_with: String
    bytes_starts_with_nocase: String
    canceltx: Bytes
    canceltx_contains: Bytes
    canceltx_in: [Bytes!]
    canceltx_not: Bytes
    canceltx_not_contains: Bytes
    canceltx_not_in: [Bytes!]
    claimtx: Bytes
    claimtx_contains: Bytes
    claimtx_in: [Bytes!]
    claimtx_not: Bytes
    claimtx_not_contains: Bytes
    claimtx_not_in: [Bytes!]
    createtx: Bytes
    createtx_contains: Bytes
    createtx_in: [Bytes!]
    createtx_not: Bytes
    createtx_not_contains: Bytes
    createtx_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    payable: BigInt
    payable_gt: BigInt
    payable_gte: BigInt
    payable_in: [BigInt!]
    payable_lt: BigInt
    payable_lte: BigInt
    payable_not: BigInt
    payable_not_in: [BigInt!]
    size: BigInt
    size_gt: BigInt
    size_gte: BigInt
    size_in: [BigInt!]
    size_lt: BigInt
    size_lte: BigInt
    size_not: BigInt
    size_not_in: [BigInt!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input BondFactory_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    bondCount: BigInt
    bondCount_gt: BigInt
    bondCount_gte: BigInt
    bondCount_in: [BigInt!]
    bondCount_lt: BigInt
    bondCount_lte: BigInt
    bondCount_not: BigInt
    bondCount_not_in: [BigInt!]
    bonds: [String!]
    bonds_contains: [String!]
    bonds_contains_nocase: [String!]
    bonds_not: [String!]
    bonds_not_contains: [String!]
    bonds_not_contains_nocase: [String!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isIssuerAllowListEnabled: Boolean
    isIssuerAllowListEnabled_in: [Boolean!]
    isIssuerAllowListEnabled_not: Boolean
    isIssuerAllowListEnabled_not_in: [Boolean!]
    isTokenAllowListEnabled: Boolean
    isTokenAllowListEnabled_in: [Boolean!]
    isTokenAllowListEnabled_not: Boolean
    isTokenAllowListEnabled_not_in: [Boolean!]
}

input Bond_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amountUnpaid: BigInt
    amountUnpaid_gt: BigInt
    amountUnpaid_gte: BigInt
    amountUnpaid_in: [BigInt!]
    amountUnpaid_lt: BigInt
    amountUnpaid_lte: BigInt
    amountUnpaid_not: BigInt
    amountUnpaid_not_in: [BigInt!]
    collateralRatio: BigInt
    collateralRatio_gt: BigInt
    collateralRatio_gte: BigInt
    collateralRatio_in: [BigInt!]
    collateralRatio_lt: BigInt
    collateralRatio_lte: BigInt
    collateralRatio_not: BigInt
    collateralRatio_not_in: [BigInt!]
    collateralToken: String
    collateralTokenAmount: BigInt
    collateralTokenAmount_gt: BigInt
    collateralTokenAmount_gte: BigInt
    collateralTokenAmount_in: [BigInt!]
    collateralTokenAmount_lt: BigInt
    collateralTokenAmount_lte: BigInt
    collateralTokenAmount_not: BigInt
    collateralTokenAmount_not_in: [BigInt!]
    collateralToken_contains: String
    collateralToken_contains_nocase: String
    collateralToken_ends_with: String
    collateralToken_ends_with_nocase: String
    collateralToken_gt: String
    collateralToken_gte: String
    collateralToken_in: [String!]
    collateralToken_lt: String
    collateralToken_lte: String
    collateralToken_not: String
    collateralToken_not_contains: String
    collateralToken_not_contains_nocase: String
    collateralToken_not_ends_with: String
    collateralToken_not_ends_with_nocase: String
    collateralToken_not_in: [String!]
    collateralToken_not_starts_with: String
    collateralToken_not_starts_with_nocase: String
    collateralToken_starts_with: String
    collateralToken_starts_with_nocase: String
    convertibleRatio: BigInt
    convertibleRatio_gt: BigInt
    convertibleRatio_gte: BigInt
    convertibleRatio_in: [BigInt!]
    convertibleRatio_lt: BigInt
    convertibleRatio_lte: BigInt
    convertibleRatio_not: BigInt
    convertibleRatio_not_in: [BigInt!]
    convertibleTokenAmount: BigInt
    convertibleTokenAmount_gt: BigInt
    convertibleTokenAmount_gte: BigInt
    convertibleTokenAmount_in: [BigInt!]
    convertibleTokenAmount_lt: BigInt
    convertibleTokenAmount_lte: BigInt
    convertibleTokenAmount_not: BigInt
    convertibleTokenAmount_not_in: [BigInt!]
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    maturityDate: BigInt
    maturityDate_gt: BigInt
    maturityDate_gte: BigInt
    maturityDate_in: [BigInt!]
    maturityDate_lt: BigInt
    maturityDate_lte: BigInt
    maturityDate_not: BigInt
    maturityDate_not_in: [BigInt!]
    maxSupply: BigInt
    maxSupply_gt: BigInt
    maxSupply_gte: BigInt
    maxSupply_in: [BigInt!]
    maxSupply_lt: BigInt
    maxSupply_lte: BigInt
    maxSupply_not: BigInt
    maxSupply_not_in: [BigInt!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    owner: Bytes
    owner_contains: Bytes
    owner_in: [Bytes!]
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    paymentToken: String
    paymentToken_contains: String
    paymentToken_contains_nocase: String
    paymentToken_ends_with: String
    paymentToken_ends_with_nocase: String
    paymentToken_gt: String
    paymentToken_gte: String
    paymentToken_in: [String!]
    paymentToken_lt: String
    paymentToken_lte: String
    paymentToken_not: String
    paymentToken_not_contains: String
    paymentToken_not_contains_nocase: String
    paymentToken_not_ends_with: String
    paymentToken_not_ends_with_nocase: String
    paymentToken_not_in: [String!]
    paymentToken_not_starts_with: String
    paymentToken_not_starts_with_nocase: String
    paymentToken_starts_with: String
    paymentToken_starts_with_nocase: String
    state: BondState
    state_in: [BondState!]
    state_not: BondState
    state_not_in: [BondState!]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    type: BondType
    type_in: [BondType!]
    type_not: BondType
    type_not_in: [BondType!]
}

input TokenBalance_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    account: String
    account_contains: String
    account_contains_nocase: String
    account_ends_with: String
    account_ends_with_nocase: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_contains_nocase: String
    account_not_ends_with: String
    account_not_ends_with_nocase: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_not_starts_with_nocase: String
    account_starts_with: String
    account_starts_with_nocase: String
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    bond: String
    bond_contains: String
    bond_contains_nocase: String
    bond_ends_with: String
    bond_ends_with_nocase: String
    bond_gt: String
    bond_gte: String
    bond_in: [String!]
    bond_lt: String
    bond_lte: String
    bond_not: String
    bond_not_contains: String
    bond_not_contains_nocase: String
    bond_not_ends_with: String
    bond_not_ends_with_nocase: String
    bond_not_in: [String!]
    bond_not_starts_with: String
    bond_not_starts_with_nocase: String
    bond_starts_with: String
    bond_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
}

input Token_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
}
